/*
# 网红点打卡攻略
 - 链接：https://pintia.cn/problem-sets/1674039732562952192/exam/problems/1674039795297153039
 - 代码长度限制：16 KB
 - 时间限制：400 ms
 - 内存限制：65536 KB

# 题目描述

一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。

## 输入格式：

首先第一行给出两个正整数：网红点的个数 $N$（$1 < N\le 200$）和网红点之间通路的条数 $M$。随后 $M$ 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 $N$ 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 `0`。

再下一行给出一个正整数 $K$，是待检验的攻略的数量。随后 $K$ 行，每行给出一条待检攻略，格式为：

$n$ $V_1$ $V_2$ $\cdots$ $V_n$

其中 $n (\le 200)$ 是攻略中的网红点数，$V_i$ 是路径上的网红点编号。这里假设你从家里出发，从 $V_1$ 开始打卡，最后从 $V_n$ 回家。

## 输出格式：

在第一行输出满足要求的攻略的个数。

在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。

题目保证至少存在一个有效攻略，并且总路费不超过 $10^9$。

## 输入样例：
```in
6 13
0 5 2
6 2 2
6 0 1
3 4 2
1 5 2
2 5 1
3 1 1
4 1 2
1 6 1
6 3 2
1 2 1
4 5 3
2 0 2
7
6 5 1 4 3 6 2
6 5 2 1 6 3 4
8 6 2 1 6 3 4 5 2
3 2 1 5
6 6 1 3 4 5 2
7 6 2 1 3 4 5 2
6 5 2 1 4 3 6
```

## 输出样例：
```out
3
5 11
```

## 样例说明：

第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。

第 1 条攻略的总路费是：(0->5) 2 + (5->1) 2 + (1->4) 2 + (4->3) 2 + (3->6) 2 + (6->2) 2 + (2->0) 2 = 14；

第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 = 11，是一条更省钱的攻略；

第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 = 11，与第 5 条花费相同，但序号较大，所以不输出。
*/

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int N = 210;
int path[N][N];

int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        path[a][b] = path[b][a] = c;
    }

    int k, cnt = 0;
    vector<pair<int, int>> cst;
    cin >> k;
    for (int i = 1; i <= k; i++)
    {
        int last = 0, x, cost = 0, vis[N] = {0};
        bool flag = true;
        cin >> x;
        for (int j = 0; j < x; j++)
        {
            int y;
            cin >> y;
            vis[y]++;
            if (flag && path[last][y] == 0)
                flag = false;
            else
                cost += path[last][y], last = y;
        }
        for (int j = 1; j <= n; j++)
            if (vis[j] != 1)
                flag = false;

        // go back home
        if (flag && path[last][0] == 0)
            flag = false;
        else
            cost += path[last][0];

        if (flag)
        {
            cnt++;
            cst.push_back({cost, i});
        }
    }

    int mini = min_element(cst.begin(), cst.end()) - cst.begin();
    cout << cnt << endl;
    cout << cst[mini].second << " " << cst[mini].first << endl;
}